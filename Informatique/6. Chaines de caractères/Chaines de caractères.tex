\documentclass[french, 11pt]{article}

\input{/home/theo/MP2I/setup.tex}

\def\chapitre{6}
\def\pagetitle{Chaînes de caractères.}

\begin{document}

\input{/home/theo/MP2I/title.tex}

\section{Caractères.}

\begin{defi}{Caractère.}{}
    Ils sont codés sur un octet en OCaml, les normes garantissent le code ASCII.\\
    Leur type est \texttt{char} en C et en OCaml, le lien entre le code ASCII et le caractère peut être obtenu par conversion explicite en C, et avec \texttt{char\_of\_int} ou \texttt{int\_of\_char} en OCaml.\\
    Il existe des opérations entre caractères : \texttt{<, <=, >, >=, ==, !=, =, <>}.\\
    On a l'assurance que les minuscules, majuscules et chiffres soient dans l'ordre.\\
    Affichage : \texttt{"\%c"} en C, \texttt{print\_char} en OCaml. 
\end{defi}

\section{Chaînes de caractères.}

Les constantes littérales seront entre guillemets.

\subsection{En C.}

\begin{defi}{}{}
    Il n'existe pas de chaîne de caractère en C, on appelle chaîne de caractères une adresse où sont stockés des caractères.\\
    Affichage : \texttt{printf("\%s", chaine);} ou bien \texttt{printf("chaine");}
\end{defi}

\subsection{En OCaml.}

\begin{defi}{}{}
    Le type est \texttt{string}.\\
    Pour accéder au $i$ème caratère, on utilise \texttt{chaine.[$i$]}.\\
    Les indices commencent à 0, les accès sont en temps constant. Les chaînes de caractère sont immuables.\\
    Affichage : \texttt{print\_string chaine;} ou bien \texttt{print\_endline chaine;}.\\
    Concaténation : \texttt{chaine1 $\Hat{}$ chaine2}.\\
    Longueur : \texttt{String.length chaine}.
\end{defi}

\section{Entrées et Sorties.}

\begin{defi}{Flux de données.}{}
    Un \bf{flux de données} est une transmissions ininterrompue d'une suite de données.\\
    Un processus a trois flux standards :
    \begin{itemize}[label=---, topsep=0pt,itemsep=-0.9 ex]
        \item \texttt{<} : entrée standard.
        \item \texttt{>} : sortie standard.
        \item \texttt{2>} : sortie d'erreur.
    \end{itemize}
\end{defi}

\subsection{En C.}

\begin{defi}{}{}
    Codes usuels :  entiers : \texttt{\%d}, flottants : \texttt{\%f}, caractères : \texttt{\%c}, pointeurs : \texttt{\%p}.\\
    Sortie standard : \texttt{printf(const char*, ...)}\\
    Elle bufferise par lignes.\n
    Sortie erreur : \texttt{fprintf(FILE*, const char*, ...);} avec \texttt{stderr} pour \texttt{FILE*}.\\
    Elle ne bufferise pas.\n
    Lire sur l'entrée standard : \texttt{scanf(const char*, ...);}
\end{defi}

\subsection{En OCaml.}

\begin{defi}{}{}
    Sortie standard : \texttt{print\_string}, \texttt{print\_int}, \texttt{print\_float}, ...\\
    Sortie erreur : \texttt{output\_string : out\_channel -> string -> unit} avec \texttt{stderr} pour \texttt{out\_channel}.\\
    Lire sur l'entrée standard : \texttt{read\_line}.\\
    Ces fonctions sont définies dans le module \texttt{Stdlib} ouvert par défaut.
\end{defi}

\section{Fichiers textuels.}
\subsection{En C.}

\begin{defi}{}{}
    On utilise \texttt{fopen(const char*, const char*);} en spécifiant le chemin du fichier et le mode d'ouverture.\\
    Lecture : \texttt{fscanf(FILE*, const char*, ...);}\\
    Écriture : \texttt{fprintf(FILE*, const char*, ...);}\\
    Fermeture : \texttt{fclose(FILE*);}\n
    En cas d'oubli de fermeture, on épuise les ressources du système et les écritures peuvent ne pas se faire. 
\end{defi}

\subsection{En OCaml.}

\begin{defi}{}{}
    Même principe :\\
    Ouverture : \texttt{open\_in} en lecture, \texttt{open\_out} en écriture.\\
    Lecture : \texttt{input\_line} ou bien \texttt{input\_char}.\\
    Écriture : \texttt{output\_string} ou bien \texttt{output\_char}.\\
    Fermeture : \texttt{close\_in} ou bien \texttt{close\_out}.\\
    En fin de fichier, on obtient l'exception \texttt{End\_of\_file}.
\end{defi}

\section{Recherche de motifs.}
\subsection{Notations.}

\begin{nota}{}{}
    Soit $T$ un texte de longueur $n$, $M$ un motif de longueur $m\leq n$, sur un même alphabet $\cursive{A}$.\\
    On utilise les notations de python sur les chaînes de caractère.\\
    On cherche $S=\{s\in\N \mid \forall i \leq m-1, ~ T[s+i]=M[i]\}$.
\end{nota}

\subsection{Algorithme naïf.}

\begin{defi}{}{}
    \begin{algorithm}[H]
        \caption{Algorithme Naïf}
        \Entree{Un texte $T$, un motif $M$}
        \Sortie{L'ensemble $S$}
        $S \gets \0$ \\
        \Pour{$s$ allant de 0 à $n-m$}{
            \Si{$M=T[s:s+m]$}{
                $S\gets S\cup\{s\}$
            }
        }
        \Retour $S$
    \end{algorithm}
    Dans le pire des cas, cet algorithme a une complexité en $\Theta(m\cdot n)$.
\end{defi}

\subsection{Algorithme de Boyer-Moore-Horspool \texorpdfstring{$\star$}{Lg}.}
\subsubsection{Principe.}

\begin{defi}{}{}
    En comparant de droite à gauche, on peut déplacer le motif plus rapidement.\\
    On applique un prétraitement sur le motif, pour connaître la dernière occurence de chaque caractère.
\end{defi}

\subsubsection{Table de saut.}

\begin{defi}{}{}
    Indexée par l'alphabet, la case $c$ donne l'indice de l'occurence la plus à droite dans $M$ privé de sa dernière lettre du caractère $c$, sinon $-1$.\\
    Ce prétraitement s'effectue avec une complexité en $O(\max(n,m))$.
\end{defi}

\subsubsection{Algorithme.}

\begin{defi}{}{}
    \begin{algorithm}[H]
        \caption{Construction de la table de saut}
        \Entree{Un motif $M$}
        \Sortie{Table de saut sur $M$}
        $T \gets $ table de saut vide.\\
        \Pour{$c$ dans $\cursive{A}$}{
            $T[c] \gets -1$.
        }
        \Pour{$i$ allant de 0 à $m-2$}{
            $T[M[i]] \gets i$.
        }
        \Retour $T$.
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Algorithme de Boyer-Moore-Horspool}
        \Entree{Un texte $T$, un motif $M$}
        \Sortie{L'ensemble $S$}
        $S \gets \0$.\\
        $T \gets $ table de saut sur $M$.\\
        $s \gets 0$.\\
        \Tq{$s\leq n-m$}{
            $i \gets m-1$.\\
            \Tq{$i\geq 0$ et $M[i]=T[s+i]$}{
                $i \gets i-1$.
            }
            \Si{$i=-1$}{
                $S\gets S\cup\{s\}$.
            }
            $s \gets s + m - \max(1, i-T[T[s+m-1]])$.
        }
        \Retour $S$.
    \end{algorithm}
\end{defi}

\subsection{Algorithme de Rabin-Karp.}

\begin{center}
    Sera ajouté plus tard (?).
\end{center}

\pagebreak

\section{Compression.}
\subsection{Lempel-Ziv-Welch.}
\begin{defi}{Algorithme Lempel-Ziv-Welch}{}
    \textbf{Principe:} parcours de gauche à droite du texte à compresser en maintenant un dictionnaire qui à un facteur du texte associe un code, qu'on suppose être le code ASCII.\n
    \begin{algorithm}[H]
        \caption{LZW Compression}
        \Entree{Un texte}
        \Sortie{Code compressé du texte}
        Créer un dictionnaire $D$.\\
        Mettre les codes ASCII des caractères dans le dictionnaire.\\
        $m \gets$ mot vide.\\
        \Tq{il y a un caractère à lire}{
            Soit $x$ ce caractère.\\
            \Si{mx est une clé de $D$}{
                $m \gets mx$.
            }\Sinon{
                Ajouter $mx$ à $D$ avec la première valeur non utilisée.\\
                Écrire le code de $m$ sur la sortie.\\
                $m \gets x$.
            }
        }
        écrire le code de $m$.
    \end{algorithm}\vspace{0.2cm}
    \begin{algorithm}[H]
        \caption{LZW Décompression}
        \Entree{Un code}
        \Sortie{Texte décompressé}
        Créer un dictionnaire $D$ double associant un code à une lettre.\\
        Remplir $D$ avec le code ASCII.\\
        $m \gets$ mot vide.\\
        \Tq{il y a un code à lire}{
            Soit $x$ ce code.\\
            \Si{$x$ est une clé de $D$}{
                $x_0 \gets$ le premier caractère du mot associé à $x$.\\
                \Si{$mx_0\notin D$}{
                    Ajouter $mx_0$ à $D$ avec la première valeur non attribuée.\\
                    Écrire $m$ sur la sortie.
                }
            }\Sinon{
                $m_0 \gets$ le premier caractère de $m$.\\
                Ajouter $mm_0$ à $D$ avec la première valeur non attribuée.\\
                Écrire $m$ sur la sortie.\\
            }
            $m \gets$ le mot associé à $x$.
        }
        écrire $m$ sur la sortie.
    \end{algorithm}
\end{defi}

\subsection{Codage de Huffman.}

\begin{defi}{Huffman. $\star$}{}
    \begin{algorithm}[H]
        \caption{Codage de Huffman}
        \Entree{Un texte}
        \Sortie{Son encodage}
        Mettre les couples (caractère, fréquence) dans une chaîne de priorité.\\
        \Tq{file contient plusieurs éléments}{
            Extraire les 2 éléments de plus basses fréquences.\\
            Créer un noeud binaire dont ces éléments sont les fils.\\
            Insérer ce noeud dans la file, avec pour fréquence la somme des fréquences de ses fils.
        }
        \Retour l'élément de la file.
    \end{algorithm}
\end{defi}

\end{document}